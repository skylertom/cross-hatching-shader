<html>

<head>
    <title>Cross Hatching Shader</title>
    <script   src="https://code.jquery.com/jquery-2.2.3.min.js"   integrity="sha256-a23g1Nt4dtEYOj7bR+vTu7+T8VP13humZFBJNIYoEJo="   crossorigin="anonymous"></script>
<head>
<script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;
    //this specifies the precision for webGL. In this case, medium.
    //Options: lowp, mediump, highp.

    uniform sampler2D textures[14];
    uniform int sampleIndex;
    uniform vec4 light_vector;
    uniform vec3 color;

    varying vec3 normal;
    varying vec2 uv;
    uniform vec2 canvasSize;
    varying vec4 worldPos;
    varying vec3 mmin, mmax;

    /* necessary because you can't index with a type "uniform" */
    vec3 getSampleFromArray(int ndx, float rotation, vec2 uv) {
        vec4 mycolor;
        /* rotate uv by angle * 90 degrees */
        float angle = (mod(rotation, 4.)) / 2.0;
        for (int i = 0; i < 7; i++) {
            if (ndx == i) {
                return texture2D(textures[i], mat2(cos(rotation), sin(rotation), -1. * sin(rotation), cos(rotation)) * uv).rgb;
            }
        }
        return mycolor.rgb;
    }

    int rotationBucket(vec3 v1, vec3 v2) {
        float angle = acos(dot(v1, v2));
        float percent = 8. * angle / (2. * 3.14159265389);
        float index = floor(percent + .5);
        return int(index);
    }

    // really should be mixing buckets of the two nearest shapes to get the
    // exact bump value
    int getBucket(float bump) {
        float step = 1.0 / 7.0;
        for (int i = 0; i < 7; i++) {
            float temp = float(i);
            if (bump < (temp / 7.0)) {
                // 0 is lightest
                return 6 - i;
            }
        }
        return 6;
    }

    void main(void) {
        vec3 up_vector = vec3(0., 1., 0.);
        vec3 finalcolor = vec3(1.0, 1.0, 1.0);
        float bump = max(0.0, dot(light_vector.xyz, normal));
        //finalcolor = getSampleFromArray(getBucket(bump), float(rotationBucket(normal, up_vector)), worldPos.st * 6.0);
        finalcolor = getSampleFromArray(getBucket(bump), -1. * acos(dot(normal, up_vector)), worldPos.st * 6.0);
    	gl_FragColor = vec4(finalcolor, 1.0);
    }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
    float PI = 3.1415926535897932384626433832795;

    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute float aVertexPos;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform vec2 mouseLocation;
    //uniform vec4 light_vector;

    varying vec3 normal;
    varying vec4 worldPos;
    varying vec2 uv;

    varying vec3 mmin, mmax;

    void main(void) {
    	normal = aVertexNormal;
    	gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        worldPos = gl_Position;
        vec3 m = vec3(mouseLocation, 1.0);
        mmax = m + .5;
        mmin = m - .5;
        if (aVertexPos == 0.0) {
            uv = vec2(.5, 0);
        }
        else if (aVertexPos == 1.0) {
            uv = vec2(0, 1);
        }
        else {
            uv = vec2(1, 1);
        }
        /* test */
        uv = vec2(aVertexPos, 0);
    }
</script>


<body onload="webGLStart();">
    <canvas id="myCanvas" onclick="mouseClick(event)" onmousemove="mouseMove(event)" style="border: none;" width="500" height="500"></canvas>
    <script type="text/javascript" src="gl-matrix-min.js"></script>
    <script type="text/javascript" src="parse.js"></script>
    <script type="text/javascript" src="start.js"></script>
</body>
</html>
